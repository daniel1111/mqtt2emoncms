
class P_DIR
{
  const IN = 1;
  const OUT = 2;
  const INOUT = 3;
}
  
class P_TYPE
 {
  const INT = 1;
  const VARCHAR = 2;
  const FLOAT = 3;
  const TEXT = 4;
}

class CNHDBAccess extends mysqli
{
  function dbglog($message)
  {
    if (function_exists("writeMsg"))
      writeMsg($message);
    //echo $message . "\n";
  }
  
// {AUTOGENERATED-SP-CALLS}

  function exec_sp($spname, &$params, &$rs)
  {
    $param_str = '';
    $pcount_in = 0;
    $pcount_out = 0;

    // Build up parameter string for SP call
    foreach ($params as $i=>$param) 
    {
      if ($param_str != '')
        $param_str .= ', ';
      
      if ($param['direction'] == P_DIR::IN)
      {
        $pcount_in++;
        $param_str .= '?';        
      } else if ($param['direction'] == P_DIR::OUT)
      {
        $pcount_out++;
        $param_str .= '@' . $i;
      } else
      {
        $this->dbglog("exec_sp> Unknown direction: [" . $param['direction'] . "]");
        return false;
      }
    }
    $call_str = 'call ' . $spname . '(' . $param_str . ')'; 
    
    // Build type list & bind params
    $type_str = '';
    $bind_params_in = array('params types');
    foreach ($params as &$param) 
    {    
      if ($param['direction'] == P_DIR::IN)
      {
        // build up type list
        switch ($param['type'])
        {
          case P_TYPE::INT:
            $type_str .= 'i';
            break;
            
          case P_TYPE::VARCHAR:
            $type_str .= 's';
            break;
          
          case P_TYPE::FLOAT:
            $type_str .= 'd';
            break;
          
          case P_TYPE::TEXT:
            $type_str .= 's';
            break;            
            
          default:
            $this->dbglog('exec_sp> Unknown type: [' . $param['type'] . ']');
        }
        
        //build param list for mysqli bind_param
        $bind_params_in[] = &$param['value'];
      }
    }
    $this->dbglog('exec_sp> sql = [' . $call_str . '], type string = [' . $type_str . ']');
    $bind_params_in[0] = $type_str;
        
    // Call the SP.
    $stmt =  $this->stmt_init();
    if (!($stmt->prepare($call_str)))
    {
      $this->dbglog("sp_exec> prepare failed!");
      return false;    
    }
        
    if (strlen($type_str) > 0)
    {
      if (!call_user_func_array(array($stmt, 'bind_param'), $bind_params_in))
      {
        $this->dbglog("sp_exec> bind_param failed!");
        return false;
      }
    }
   
    if (!$stmt->execute())
    {
      $this->dbglog("sp_exec> exec failed: [" . $stmt->error . "]");
      $stmt->close();
      return false;
    } 
    
    // Check for a result set.
    if ($this->more_results())
    {
      $this->dbglog("SP returned a result set");   
      $rs = $this->get_rs($stmt);
    }
    $stmt->close();
    
    // Clear out any additional resultsets produced by the SP (don't know how to
    // get them, but they cause problems if not cleared)
    while ($this->more_results())
    {
      if ($result = $this->use_result())
        $result->close();
      $this->next_result();
    }
    
  
    if ($pcount_out <= 0)
    {
      // If no output paramters from SP to get, we're done.
      return true;
    }
    
    $bind_params_out = array();
    $sql_str = 'select ';
    foreach ($params as $i=>&$param) 
    {
      if ($param['direction'] == P_DIR::OUT)
      {
        if ($sql_str != 'select ')
          $sql_str .= ', ';
        
        $sql_str .= '@' . $i;
        $bind_params_out[] = &$param['value'];
      }
    }
    
    $this->dbglog('exec_sp> get output, sql = [' . $sql_str . ']');
    
    
    $stmt =  $this->stmt_init();
    if (!($stmt->prepare($sql_str)))
    {
      $this->dbglog("sp_exec> prepare failed! (get results): " . $this->error);
      return false;    
    }
    
    if (!$stmt->execute())
    {
      $this->dbglog("sp_exec> exec failed: [" . $stmt->error . "]");
      $stmt->close();
      return false;
    } 
  
    if (!call_user_func_array(array($stmt, 'bind_result'), $bind_params_out))
    {
      $this->dbglog("sp_exec> bind_result failed!: [" . $stmt->error . "]");
      $stmt->close();  
      return false;
    }     
    if ($stmt->fetch())
    {
      $stmt->close();  
      return true;
    }
  }

  function get_rs(&$stmt)
  {
    $this->dbglog("get_rs> Entered");

    $row = array();
    $rows = array();
    $bind_params = array();
          
    // Get result details (fields, etc)
    $res = $stmt->result_metadata();
    if (!$res)
    {
      $this->dbglog("get_rs> result_metadata failed: [" . $this->error . "]");
      $stmt->close();
      return false;
    }
      
    // build bind params array  
    while($field = $res->fetch_field())
    {
      $row[$field->name] = "";
      $bind_params[] = &$row[$field->name];
    }
 
    if (!call_user_func_array(array($stmt, 'bind_result'), $bind_params))
    {
      $this->dbglog("get_rs> bind_result failed!: [" . $stmt->error . "]");
      $stmt->close();  
      return false;
    }  
 
    // Get result set into array
    $i = 0;
    while ($stmt->fetch())
    {
      foreach ($row as $field => $value) 
      {
        $rows[$i][$field] = $value;
      }
      $i++;    
    }
    
    $this->dbglog("get_rs> returning $i rows");
    return $rows;
  }

}



?>